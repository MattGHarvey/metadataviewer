<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Online JPG Metadata Viewer & Instagram Panorama Splitter</title>
		<meta
			name="description"
			content="View JPG EXIF metadata and split panoramic photos for Instagram. No uploads, full privacy. Drag and drop to see metadata, location, and create Instagram-ready carousel posts."
		/>
		<meta
			name="keywords"
			content="EXIF, JPG, metadata, photo, privacy, map, GPS, online viewer, browser, panorama, Instagram, carousel, split, social media"
		/>

		<!-- PWA Icons -->
		<link rel="icon" type="image/png" href="./images/icon-192.png" />
		<link rel="apple-touch-icon" href="./images/icon-192.png" />

		<!-- PWA Manifest -->
		<link rel="manifest" href="./manifest.json" />

		<!-- PWA Meta Tags -->
		<meta name="theme-color" content="#1976d2" />
		<meta name="mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="default" />
		<meta name="apple-mobile-web-app-title" content="EXIF Viewer" />

		<link rel="canonical" href="https://exif.robotsprocket.com/" />
		<meta property="og:title" content="Online JPG EXIF Metadata Viewer" />
		<meta
			property="og:description"
			content="View and map JPG EXIF metadata instantly in your browser. No uploads, full privacy."
		/>
		<meta
			property="og:image"
			content="https://exif.robotsprocket.com/images/icon-512.png"
		/>
		<meta property="og:type" content="website" />
		<meta property="og:url" content="https://exif.robotsprocket.com/" />
		<script>
			fetch("ga-snippet.html")
				.then((response) => (response.ok ? response.text() : ""))
				.then((html) => {
					if (html) {
						const gaDiv = document.createElement("div");
						gaDiv.innerHTML = html;
						document.head.append(...gaDiv.childNodes);
					}
				});
		</script>

		<!-- PWA Service Worker -->
		<script>
			// Register service worker
			if ("serviceWorker" in navigator) {
				window.addEventListener("load", () => {
					navigator.serviceWorker
						.register("./sw.js")
						.then((registration) => {
							// Service worker registered successfully
						})
						.catch((error) => {
							console.log("SW registration failed:", error);
						});
				});
			}

			// PWA Install functionality
			let deferredPrompt;
			let installButton;

			window.addEventListener("beforeinstallprompt", (e) => {
				e.preventDefault();
				deferredPrompt = e;
				showInstallButton();
			});

			function showInstallButton() {
				installButton = document.createElement("button");
				installButton.textContent = "📱 Install App";
				installButton.style.cssText = `
					position: fixed;
					top: 20px;
					right: 20px;
					background: #1976d2;
					color: white;
					border: none;
					padding: 12px 16px;
					border-radius: 8px;
					cursor: pointer;
					font-size: 14px;
					font-weight: 500;
					z-index: 1000;
					box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
					transition: all 0.2s ease;
				`;

				installButton.addEventListener("mouseover", () => {
					installButton.style.transform = "translateY(-1px)";
					installButton.style.boxShadow =
						"0 6px 16px rgba(25, 118, 210, 0.4)";
				});

				installButton.addEventListener("mouseout", () => {
					installButton.style.transform = "translateY(0)";
					installButton.style.boxShadow =
						"0 4px 12px rgba(25, 118, 210, 0.3)";
				});

				installButton.addEventListener("click", () => {
					if (deferredPrompt) {
						deferredPrompt.prompt();
						deferredPrompt.userChoice.then((choiceResult) => {
							if (choiceResult.outcome === "accepted") {
								hideInstallButton();
							}
							deferredPrompt = null;
						});
					}
				});

				document.body.appendChild(installButton);
			}

			function hideInstallButton() {
				if (installButton && installButton.parentNode) {
					installButton.parentNode.removeChild(installButton);
					installButton = null;
				}
			}

			// Hide button if app is already installed
			window.addEventListener("appinstalled", () => {
				hideInstallButton();
			});

			// File Handling API - Handle files opened with the PWA
			if ("launchQueue" in window) {
				window.launchQueue.setConsumer((launchParams) => {
					if (launchParams.files && launchParams.files.length > 0) {
						// Process the first file
						handleLaunchedFile(launchParams.files[0]);

						// Show a welcome message for file opening
						showWelcomeMessage();
					}
				});
			}

			// Also check URL parameters on page load (alternative method)
			window.addEventListener("load", () => {
				// Check if launched via file association
				if (
					window.location.search.includes("file") ||
					window.location.hash
				) {
					showWelcomeMessage();
				}
			});

			function showWelcomeMessage() {
				const message = document.createElement("div");
				message.textContent =
					"🎉 Welcome! Your file is being processed...";
				message.style.cssText = `
					position: fixed;
					top: 50%;
					left: 50%;
					transform: translate(-50%, -50%);
					background: #1976d2;
					color: white;
					padding: 20px 30px;
					border-radius: 12px;
					font-size: 16px;
					font-weight: 500;
					z-index: 1002;
					box-shadow: 0 8px 32px rgba(25, 118, 210, 0.3);
					opacity: 0;
					transition: opacity 0.3s ease;
				`;

				document.body.appendChild(message);

				// Fade in
				setTimeout(() => {
					message.style.opacity = "1";
				}, 100);

				// Remove after 2 seconds
				setTimeout(() => {
					message.style.opacity = "0";
					setTimeout(() => {
						if (message.parentNode) {
							message.parentNode.removeChild(message);
						}
					}, 300);
				}, 2000);
			}

			async function handleLaunchedFile(fileHandle) {
				try {
					// Get the file from the file handle
					const file = await fileHandle.getFile();

					// Verify it's a JPEG file
					if (
						file.type === "image/jpeg" ||
						file.name.toLowerCase().endsWith(".jpg") ||
						file.name.toLowerCase().endsWith(".jpeg")
					) {
						// Wait for the DOM and main script to be ready
						if (document.readyState === "loading") {
							document.addEventListener(
								"DOMContentLoaded",
								() => {
									processFileWhenReady(file);
								}
							);
						} else {
							processFileWhenReady(file);
						}

						// Show a notification that the file was opened
						showFileOpenedNotification(file.name);
					} else {
						alert("Please select a JPEG image file.");
					}
				} catch (error) {
					console.error("Error handling launched file:", error);
				}
			}

			function processFileWhenReady(file) {
				// Wait for the main handleFile function to be available
				const checkForHandleFile = setInterval(() => {
					if (
						window.handleFile &&
						typeof window.handleFile === "function"
					) {
						clearInterval(checkForHandleFile);
						window.handleFile(file);
					} else if (typeof handleFile === "function") {
						clearInterval(checkForHandleFile);
						handleFile(file);
					}
				}, 100);

				// Fallback timeout after 5 seconds
				setTimeout(() => {
					clearInterval(checkForHandleFile);
				}, 5000);
			}

			function showFileOpenedNotification(fileName) {
				const notification = document.createElement("div");
				notification.textContent = `📂 Opened: ${fileName}`;
				notification.style.cssText = `
					position: fixed;
					top: 70px;
					right: 20px;
					background: #4caf50;
					color: white;
					padding: 12px 16px;
					border-radius: 8px;
					font-size: 14px;
					z-index: 1001;
					box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
					opacity: 0;
					transition: opacity 0.3s ease;
				`;

				document.body.appendChild(notification);

				// Fade in
				setTimeout(() => {
					notification.style.opacity = "1";
				}, 100);

				// Remove after 3 seconds
				setTimeout(() => {
					notification.style.opacity = "0";
					setTimeout(() => {
						if (notification.parentNode) {
							notification.parentNode.removeChild(notification);
						}
					}, 300);
				}, 3000);
			}
		</script>
		<link
			rel="stylesheet"
			href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
		/>
		<style>
			html,
			body {
				font-family: "Segoe UI", "Helvetica Neue", Arial,
					"Liberation Sans", sans-serif;
			}
			#drop-area {
				border: 2px dashed #ccc;
				border-radius: 20px;
				width: 400px;
				height: 200px;
				margin: 50px auto;
				display: flex;
				align-items: center;
				justify-content: center;
				font-size: 1.2em;
				color: #888;
			}
			#image-preview {
				width: 80%;
				margin: 20px auto;
				text-align: center;
			}
			#metadata {
				width: 60%;
				margin: 20px auto;
				background: #f9f9f9;
				padding: 20px;
				border-radius: 10px;
				font-family: monospace;
				white-space: pre-wrap;
			}
			#metadata table {
				font-size: 1em;
				width: 50%;
				margin: 0 auto;
				border-collapse: collapse;
			}
			#metadata th,
			#metadata td {
				border: 1px solid #ccc;
				padding: 2px 6px;
				text-align: left;
			}
			#metadata th {
				background-color: #f2f2f2;
			}
			#map {
				width: 50%;
				height: 500px;
				margin: 20px auto;
				border-radius: 10px;
				border: 1px solid #ccc;
				display: none;
			}
			
			/* Panorama splitter modal styles */
			@media (max-width: 768px) {
				#pano-splitter-modal .modal-content {
					margin: 20px;
					max-width: calc(100% - 40px);
					max-height: calc(100% - 40px);
				}
				
				#splitter-content > div {
					flex-direction: column !important;
				}
				
				#splitter-content > div > div {
					min-width: auto !important;
				}
			}
			
			.slice-item:hover {
				transform: scale(1.05);
				transition: transform 0.2s ease;
			}
			
			/* Aspect ratio support with fallback */
			.slice-aspect-container {
				width: 100%;
				position: relative;
				overflow: hidden;
				border-radius: 4px;
			}
			
			.slice-aspect-container::before {
				content: "";
				display: block;
				padding-top: 125%; /* 5/4 = 1.25 = 125% for 4:5 aspect ratio */
			}
			
			.slice-aspect-container img {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				object-fit: cover;
			}
			
			/* Modern browsers with aspect-ratio support */
			@supports (aspect-ratio: 4/5) {
				.slice-aspect-container {
					aspect-ratio: 4/5;
				}
				
				.slice-aspect-container::before {
					display: none;
				}
				
				.slice-aspect-container img {
					position: static;
				}
			}
		</style>
	</head>
	<body>
		<!-- Privacy blurb at the top of the page -->
		<div
			style="
				width: 80%;
				margin: 20px auto 0 auto;
				padding: 10px 20px;
				background: #eaf6ff;
				border-radius: 10px;
				border: 1px solid #b3d8ff;
				font-size: 1.1em;
				color: #333;
			"
		>
			<strong>Privacy Notice:</strong> All metadata viewing and panorama processing is done entirely in
			your browser. Your photos are never uploaded to any server.
		</div>
		<!-- Main heading -->
		<h1
			style="
				width: 80%;
				margin: 20px auto 0 auto;
				text-align: center;
				font-size: 2em;
			"
		>
			Online JPG EXIF Metadata Viewer & Panorama Splitter
		</h1>
		<!-- Drag-and-drop area for JPG files -->
		<div id="drop-area">Drop JPG file here</div>

		<!-- File picker for JPG files -->
		<div style="width: 80%; margin: 10px auto; text-align: center">
			<label for="file-picker" style="font-size: 1.1em"
				>Or select a JPG file:</label
			>
			<input
				type="file"
				id="file-picker"
				accept="image/jpeg"
				style="margin-left: 10px"
			/>
		</div>
		<!-- Image preview area -->
		<div
			id="image-preview"
			style="width: 80%; margin: 20px auto; text-align: center"
		></div>
		
		<!-- Panorama splitter button area -->
		<div
			id="splitter-button-area"
			style="width: 80%; margin: 10px auto; text-align: center; display: none;"
		>
			<button
				id="split-panorama-btn"
				style="
					background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
					color: white;
					border: none;
					padding: 12px 24px;
					border-radius: 8px;
					font-size: 16px;
					font-weight: 600;
					cursor: pointer;
					box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
					transition: all 0.3s ease;
					margin: 10px;
				"
				onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(102, 126, 234, 0.4)'"
				onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.3)'"
			>
				📱 Split for Instagram
			</button>
		</div>
		
		<!-- Panorama splitter modal -->
		<div id="pano-splitter-modal" style="display: none;">
			<div class="modal-overlay" style="
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.7);
				z-index: 1000;
				display: flex;
				align-items: center;
				justify-content: center;
			">
				<div class="modal-content" style="
					background: white;
					border-radius: 12px;
					padding: 24px;
					max-width: 90%;
					max-height: 90%;
					overflow-y: auto;
					position: relative;
					box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
				">
					<button id="close-modal" style="
						position: absolute;
						top: 12px;
						right: 12px;
						background: none;
						border: none;
						font-size: 24px;
						cursor: pointer;
						color: #666;
						width: 32px;
						height: 32px;
						border-radius: 50%;
						display: flex;
						align-items: center;
						justify-content: center;
						transition: background 0.2s;
					"
					onmouseover="this.style.background='#f0f0f0'"
					onmouseout="this.style.background='none'"
					>&times;</button>
					
					<h2 style="margin: 0 0 16px 0; color: #333;">Instagram Panorama Splitter</h2>
					<p style="margin: 0 0 24px 0; color: #666;">Split your panoramic photo into Instagram-friendly carousel posts</p>
					
					<div id="splitter-content">
						<!-- Content will be populated by JavaScript -->
					</div>
				</div>
			</div>
		</div>
		
		<!-- Metadata table area -->
		<div id="metadata"></div>
		<!-- Map area for GPS coordinates -->
		<div id="map"></div>
		<!-- Footer with copyright and links -->
		<footer
			style="
				width: 80%;
				margin: 40px auto 0 auto;
				padding: 16px 0;
				text-align: center;
				font-size: 1em;
				color: #555;
			"
		>
			&copy; 2025 Matt Harvey &mdash;
			<a
				href="https://www.robotsprocket.com"
				target="_blank"
				rel="noopener"
				style="color: #1976d2; text-decoration: none"
				>[robotSprocket]</a
			>
			&mdash;
			<a
				href="https://www.75centralphotography.com"
				target="_blank"
				rel="noopener"
				style="color: #1976d2; text-decoration: none"
				>75CentralPhotography</a
			>
			&mdash;
			<a
				href="https://github.com/MattGHarvey/metadataviewer"
				target="_blank"
				rel="noopener"
				style="color: #1976d2; text-decoration: none"
				>GitHub Repository</a
			>

			<!-- Social Sharing Icons -->
			<div
				style="
					margin-top: 16px;
					display: flex;
					justify-content: center;
					gap: 12px;
					align-items: center;
				"
			>
				<span style="font-size: 14px; color: #777; margin-right: 8px"
					>Share:</span
				>

				<!-- Twitter/X -->
				<a
					href="#"
					onclick="shareToTwitter(); return false;"
					style="
						display: inline-flex;
						align-items: center;
						justify-content: center;
						width: 36px;
						height: 36px;
						background: #1da1f2;
						border-radius: 50%;
						text-decoration: none;
						transition: opacity 0.3s ease;
					"
					title="Share on Twitter/X"
					onmouseover="this.style.opacity='0.8'"
					onmouseout="this.style.opacity='1'"
				>
					<svg
						width="18"
						height="18"
						viewBox="0 0 24 24"
						fill="white"
					>
						<path
							d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"
						/>
					</svg>
				</a>

				<!-- Facebook -->
				<a
					href="#"
					onclick="shareToFacebook(); return false;"
					style="
						display: inline-flex;
						align-items: center;
						justify-content: center;
						width: 36px;
						height: 36px;
						background: #1877f2;
						border-radius: 50%;
						text-decoration: none;
						transition: opacity 0.3s ease;
					"
					title="Share on Facebook"
					onmouseover="this.style.opacity='0.8'"
					onmouseout="this.style.opacity='1'"
				>
					<svg
						width="18"
						height="18"
						viewBox="0 0 24 24"
						fill="white"
					>
						<path
							d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"
						/>
					</svg>
				</a>

				<!-- LinkedIn -->
				<a
					href="#"
					onclick="shareToLinkedIn(); return false;"
					style="
						display: inline-flex;
						align-items: center;
						justify-content: center;
						width: 36px;
						height: 36px;
						background: #0077b5;
						border-radius: 50%;
						text-decoration: none;
						transition: opacity 0.3s ease;
					"
					title="Share on LinkedIn"
					onmouseover="this.style.opacity='0.8'"
					onmouseout="this.style.opacity='1'"
				>
					<svg
						width="18"
						height="18"
						viewBox="0 0 24 24"
						fill="white"
					>
						<path
							d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"
						/>
					</svg>
				</a>

				<!-- Reddit -->
				<a
					href="#"
					onclick="shareToReddit(); return false;"
					style="
						display: inline-flex;
						align-items: center;
						justify-content: center;
						width: 36px;
						height: 36px;
						background: #ff4500;
						border-radius: 50%;
						text-decoration: none;
						transition: opacity 0.3s ease;
					"
					title="Share on Reddit"
					onmouseover="this.style.opacity='0.8'"
					onmouseout="this.style.opacity='1'"
				>
					<svg
						width="18"
						height="18"
						viewBox="0 0 24 24"
						fill="white"
					>
						<path
							d="M12 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0zm5.01 4.744c.688 0 1.25.561 1.25 1.249a1.25 1.25 0 0 1-2.498.056l-2.597-.547-.8 3.747c1.824.07 3.48.632 4.674 1.488.308-.309.73-.491 1.207-.491.968 0 1.754.786 1.754 1.754 0 .716-.435 1.333-1.01 1.614a3.111 3.111 0 0 1 .042.52c0 2.694-3.13 4.87-7.004 4.87-3.874 0-7.004-2.176-7.004-4.87 0-.183.015-.366.043-.534A1.748 1.748 0 0 1 4.028 12c0-.968.786-1.754 1.754-1.754.463 0 .898.196 1.207.49 1.207-.883 2.878-1.43 4.744-1.487l.885-4.182a.342.342 0 0 1 .14-.197.35.35 0 0 1 .238-.042l2.906.617a1.214 1.214 0 0 1 1.108-.701zM9.25 12C8.561 12 8 12.562 8 13.25c0 .687.561 1.248 1.25 1.248.687 0 1.248-.561 1.248-1.249 0-.688-.561-1.249-1.249-1.249zm5.5 0c-.687 0-1.248.561-1.248 1.25 0 .687.561 1.248 1.249 1.248.688 0 1.249-.561 1.249-1.249 0-.687-.562-1.249-1.25-1.249zm-5.466 3.99a.327.327 0 0 0-.231.094.33.33 0 0 0 0 .463c.842.842 2.484.913 2.961.913.477 0 2.105-.056 2.961-.913a.361.361 0 0 0 .029-.463.33.33 0 0 0-.464 0c-.547.533-1.684.73-2.512.73-.828 0-1.979-.196-2.512-.73a.326.326 0 0 0-.232-.095z"
						/>
					</svg>
				</a>

				<!-- Email -->
				<a
					href="#"
					onclick="shareByEmail(); return false;"
					style="
						display: inline-flex;
						align-items: center;
						justify-content: center;
						width: 36px;
						height: 36px;
						background: #34495e;
						border-radius: 50%;
						text-decoration: none;
						transition: opacity 0.3s ease;
					"
					title="Share by Email"
					onmouseover="this.style.opacity='0.8'"
					onmouseout="this.style.opacity='1'"
				>
					<svg
						width="18"
						height="18"
						viewBox="0 0 24 24"
						fill="white"
					>
						<path
							d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"
						/>
					</svg>
				</a>

				<!-- Copy Link -->
				<a
					href="#"
					onclick="copyLink(); return false;"
					style="
						display: inline-flex;
						align-items: center;
						justify-content: center;
						width: 36px;
						height: 36px;
						background: #6c757d;
						border-radius: 50%;
						text-decoration: none;
						transition: opacity 0.3s ease;
					"
					title="Copy Link"
					onmouseover="this.style.opacity='0.8'"
					onmouseout="this.style.opacity='1'"
				>
					<svg
						width="18"
						height="18"
						viewBox="0 0 24 24"
						fill="white"
					>
						<path
							d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"
						/>
					</svg>
				</a>
			</div>
		</footer>
		<script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
		<script src="./js/jszip.min.js"></script>
		<script src="./js/FileSaver.min.js"></script>
		<script>
			// Get references to DOM elements
			const dropArea = document.getElementById("drop-area");
			const metadataDiv = document.getElementById("metadata");
			const mapDiv = document.getElementById("map");
			const imagePreviewDiv = document.getElementById("image-preview");
			const filePicker = document.getElementById("file-picker");
			const splitterButtonArea = document.getElementById("splitter-button-area");
			const splitPanoramaBtn = document.getElementById("split-panorama-btn");
			const panoSplitterModal = document.getElementById("pano-splitter-modal");
			const closeModalBtn = document.getElementById("close-modal");
			const splitterContent = document.getElementById("splitter-content");

			// Global variable to track the current map instance
			let currentMap = null;

			// Global variable to track the current map button container
			let currentButtonContainer = null;
			
			// Global variables for panorama splitter
			let currentImageFile = null;
			let originalImage = null;
			let slicedImages = [];
			let fullViewImage = null;
			
			// Panorama splitter configuration
			const aspectRatio = 4/5; // Instagram 4:5 aspect ratio
			const standardWidth = 1080;
			const standardHeight = Math.round(standardWidth / aspectRatio); // 1350
			const minSlices = 2;

			// Panorama splitter functions
			function isPanorama(width, height) {
				return width > height && (width / height) >= 1.5;
			}
			
			function showSplitterButton() {
				splitterButtonArea.style.display = 'block';
			}
			
			function hideSplitterButton() {
				splitterButtonArea.style.display = 'none';
			}
			
			function openSplitterModal() {
				if (!currentImageFile) return;
				
				panoSplitterModal.style.display = 'block';
				document.body.style.overflow = 'hidden';
				
				// Initialize the splitter interface
				initializeSplitterInterface();
			}
			
			function closeSplitterModal() {
				panoSplitterModal.style.display = 'none';
				document.body.style.overflow = 'auto';
				
				// Reset splitter state
				originalImage = null;
				slicedImages = [];
				fullViewImage = null;
			}
			
			function initializeSplitterInterface() {
				splitterContent.innerHTML = `
					<div style="display: flex; gap: 24px; flex-wrap: wrap;">
						<div style="flex: 1; min-width: 300px;">
							<h3 style="margin: 0 0 12px 0; color: #333;">Preview</h3>
							<div style="border: 2px dashed #ddd; border-radius: 8px; padding: 16px; text-align: center; margin-bottom: 16px;">
								<img id="splitter-preview" src="" alt="Image preview" style="max-width: 100%; max-height: 300px; border-radius: 4px;">
							</div>
							<div style="background: #f8f9fa; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
								<h4 style="margin: 0 0 8px 0; color: #333;">Image Details</h4>
								<p style="margin: 4px 0; color: #666;">Original Size: <span id="original-size">-</span></p>
								<p style="margin: 4px 0; color: #666;">Scaled Size: <span id="scaled-size">-</span></p>
								<p style="margin: 4px 0; color: #666;">Number of Slices: <span id="slice-count">-</span></p>
								<p style="margin: 4px 0; color: #666;">Slice Resolution: <span id="slice-resolution">-</span></p>
							</div>
							<div style="margin-bottom: 16px;">
								<label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
									<input type="checkbox" id="high-res-toggle" checked style="width: 16px; height: 16px;">
									<span style="color: #333; font-weight: 500;">High Resolution Mode</span>
								</label>
								<p style="margin: 4px 0 0 24px; color: #666; font-size: 14px;">Uses maximum possible resolution from your image</p>
							</div>
							<div style="display: flex; gap: 12px;">
								<button id="process-btn" style="
									flex: 1;
									background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
									color: white;
									border: none;
									padding: 12px 16px;
									border-radius: 6px;
									font-weight: 600;
									cursor: pointer;
									transition: all 0.2s;
								">Generate Slices</button>
								<button id="reset-splitter-btn" style="
									background: #f8f9fa;
									color: #666;
									border: 1px solid #ddd;
									padding: 12px 16px;
									border-radius: 6px;
									cursor: pointer;
									transition: all 0.2s;
								">Reset</button>
							</div>
						</div>
						<div style="flex: 1; min-width: 300px;">
							<div id="result-container" style="display: none;">
								<h3 style="margin: 0 0 12px 0; color: #333;">Sliced Images</h3>
								<div id="slices-preview" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px; margin-bottom: 16px;"></div>
								<button id="download-btn" style="
									width: 100%;
									background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
									color: white;
									border: none;
									padding: 12px 16px;
									border-radius: 6px;
									font-weight: 600;
									cursor: pointer;
									transition: all 0.2s;
								">Download All Slices as ZIP</button>
							</div>
						</div>
					</div>
				`;
				
				// Setup event listeners for the splitter interface
				setupSplitterEventListeners();
				
				// Load the current image
				loadImageForSplitting();
			}
			
			function setupSplitterEventListeners() {
				const highResToggle = document.getElementById('high-res-toggle');
				const processBtn = document.getElementById('process-btn');
				const resetBtn = document.getElementById('reset-splitter-btn');
				const downloadBtn = document.getElementById('download-btn');
				
				highResToggle.addEventListener('change', () => {
					if (originalImage) {
						updateImageDetails();
					}
				});
				
				processBtn.addEventListener('click', () => {
					processImageForSlicing();
				});
				
				resetBtn.addEventListener('click', () => {
					resetSplitterInterface();
				});
				
				downloadBtn.addEventListener('click', () => {
					downloadZip();
				});
			}
			
			function loadImageForSplitting() {
				if (!currentImageFile) return;
				
				const reader = new FileReader();
				reader.onload = (e) => {
					const img = new Image();
					img.onload = () => {
						originalImage = {
							element: img,
							width: img.width,
							height: img.height,
							src: e.target.result
						};
						
						// Update preview
						const previewImg = document.getElementById('splitter-preview');
						previewImg.src = e.target.result;
						
						// Update image details
						updateImageDetails();
					};
					img.src = e.target.result;
				};
				reader.readAsDataURL(currentImageFile);
			}
			
			function calculateOptimalScaling(originalWidth, originalHeight, highResMode) {
				// Default to standard resolution
				let sliceWidth = standardWidth;
				let sliceHeight = standardHeight;
				
				// For high-res mode: calculate the maximum possible slice size while maintaining aspect ratio
				if (highResMode) {
					// Calculate maximum height based on original image height
					sliceHeight = originalHeight;
					// Calculate corresponding width based on 4:5 aspect ratio
					sliceWidth = Math.round(sliceHeight * aspectRatio);
				}
				
				// Initial scaling based on height
				const scaleFactor = sliceHeight / originalHeight;
				const baseScaledWidth = Math.round(originalWidth * scaleFactor);
				
				// Calculate how many full slices we can get
				const fullSlices = Math.floor(baseScaledWidth / sliceWidth);
				
				// Calculate the remaining width after using full slices
				const remainingWidth = baseScaledWidth - (fullSlices * sliceWidth);
				
				let finalSliceCount, finalScaledWidth, finalScaledHeight;
				
				// Ensure a minimum of 2 slices
				if (fullSlices < minSlices) {
					finalSliceCount = minSlices;
					finalScaledWidth = minSlices * sliceWidth;
					// Calculate height based on maintaining aspect ratio
					finalScaledHeight = Math.round((finalScaledWidth / originalWidth) * originalHeight);
				}
				// If remaining width is more than half a slice, add another slice
				else if (remainingWidth > (sliceWidth / 2)) {
					finalSliceCount = fullSlices + 1;
					finalScaledWidth = finalSliceCount * sliceWidth;
					// Adjust the scale factor to fit exactly the number of slices
					const adjustedScaleFactor = finalScaledWidth / originalWidth;
					finalScaledHeight = Math.round(originalHeight * adjustedScaleFactor);
				} 
				// Otherwise use the original number of slices
				else {
					finalSliceCount = fullSlices;
					finalScaledWidth = finalSliceCount * sliceWidth;
					finalScaledHeight = sliceHeight;
				}
				
				return {
					scaledWidth: finalScaledWidth,
					scaledHeight: finalScaledHeight,
					sliceCount: finalSliceCount,
					sliceWidth: sliceWidth,
					sliceHeight: sliceHeight
				};
			}
			
			function updateImageDetails() {
				if (!originalImage) return;
				
				const highResToggle = document.getElementById('high-res-toggle');
				const isHighResMode = highResToggle.checked;
				const { scaledWidth, scaledHeight, sliceCount, sliceWidth, sliceHeight } = calculateOptimalScaling(
					originalImage.width, 
					originalImage.height, 
					isHighResMode
				);
				
				// Update image details
				document.getElementById('original-size').textContent = `${originalImage.width}px × ${originalImage.height}px`;
				document.getElementById('scaled-size').textContent = `${scaledWidth}px × ${scaledHeight}px`;
				document.getElementById('slice-count').textContent = sliceCount;
				document.getElementById('slice-resolution').textContent = `${sliceWidth}px × ${sliceHeight}px`;
			}
			
			function processImageForSlicing() {
				if (!originalImage) return;
				
				const highResToggle = document.getElementById('high-res-toggle');
				const isHighResMode = highResToggle.checked;
				const canvas = document.createElement('canvas');
				const ctx = canvas.getContext('2d');
				
				// Calculate optimal scaling and slicing
				const { scaledWidth, scaledHeight, sliceCount, sliceWidth, sliceHeight } = calculateOptimalScaling(
					originalImage.width, 
					originalImage.height,
					isHighResMode
				);
				
				// Set canvas dimensions
				canvas.width = scaledWidth;
				canvas.height = scaledHeight;
				
				// Draw scaled image
				ctx.drawImage(originalImage.element, 0, 0, scaledWidth, scaledHeight);
				
				slicedImages = [];
				
				// Create each slice
				for (let i = 0; i < sliceCount; i++) {
					const sliceCanvas = document.createElement('canvas');
					const sliceCtx = sliceCanvas.getContext('2d');
					
					sliceCanvas.width = sliceWidth;
					sliceCanvas.height = sliceHeight;
					
					// Draw slice portion
					sliceCtx.drawImage(
						canvas, 
						i * sliceWidth, 0, sliceWidth, scaledHeight,
						0, 0, sliceWidth, sliceHeight
					);
					
					// Convert to data URL
					const dataURL = sliceCanvas.toDataURL('image/jpeg', 0.95);
					
					slicedImages.push({
						dataURL,
						number: i + 1,
						width: sliceWidth,
						height: sliceHeight
					});
				}
				
				// Create the full panorama view on white background
				createFullViewImage(sliceWidth, sliceHeight);
				
				// Show results
				displaySplitterResults();
			}
			
			function createFullViewImage(sliceWidth, sliceHeight) {
				if (!originalImage) return;
				
				// Create a canvas with the same aspect ratio as the slices
				const fullCanvas = document.createElement('canvas');
				const fullCtx = fullCanvas.getContext('2d');
				
				// Use the same dimensions as the slices for consistency
				fullCanvas.width = sliceWidth;
				fullCanvas.height = sliceHeight;
				
				// Fill with white background
				fullCtx.fillStyle = '#FFFFFF';
				fullCtx.fillRect(0, 0, sliceWidth, sliceHeight);
				
				// Calculate the scale for the panorama to fit within the frame with margins
				const margin = Math.round(sliceWidth * 0.08); // 8% margin
				const availableWidth = sliceWidth - (margin * 2);
				const availableHeight = sliceHeight - (margin * 2);
				
				// Determine which dimension constrains the scaling
				const originalAspectRatio = originalImage.width / originalImage.height;
				let scaledPanoWidth, scaledPanoHeight;
				
				if (originalAspectRatio > availableWidth / availableHeight) {
					// Width is the constraining factor
					scaledPanoWidth = availableWidth;
					scaledPanoHeight = scaledPanoWidth / originalAspectRatio;
				} else {
					// Height is the constraining factor
					scaledPanoHeight = availableHeight;
					scaledPanoWidth = scaledPanoHeight * originalAspectRatio;
				}
				
				// Calculate position to center the image
				const x = Math.round((sliceWidth - scaledPanoWidth) / 2);
				const y = Math.round((sliceHeight - scaledPanoHeight) / 2);
				
				// Draw the scaled panorama centered on the white canvas
				fullCtx.drawImage(
					originalImage.element,
					0, 0, originalImage.width, originalImage.height,
					x, y, scaledPanoWidth, scaledPanoHeight
				);
				
				// Add a subtle border
				fullCtx.strokeStyle = '#EEEEEE';
				fullCtx.lineWidth = 1;
				fullCtx.strokeRect(x - 1, y - 1, scaledPanoWidth + 2, scaledPanoHeight + 2);
				
				// Convert to data URL
				fullViewImage = {
					dataURL: fullCanvas.toDataURL('image/jpeg', 0.95),
					width: sliceWidth,
					height: sliceHeight
				};
			}
			
			function displaySplitterResults() {
				const slicesPreview = document.getElementById('slices-preview');
				const resultContainer = document.getElementById('result-container');
				
				slicesPreview.innerHTML = '';
				
				// Add the full view as the first item with special styling
				if (fullViewImage) {
					const fullViewItem = document.createElement('div');
					fullViewItem.style.cssText = `
						border: 2px solid #667eea;
						border-radius: 6px;
						overflow: hidden;
						background: white;
						text-align: center;
						padding: 8px;
					`;
					
					const imgContainer = document.createElement('div');
					imgContainer.className = 'slice-aspect-container';
					
					const img = document.createElement('img');
					img.src = fullViewImage.dataURL;
					img.alt = 'Full Panorama View';
					
					const label = document.createElement('div');
					label.textContent = 'Full View';
					label.style.cssText = 'font-size: 12px; font-weight: 600; color: #667eea; margin-top: 4px;';
					
					imgContainer.appendChild(img);
					fullViewItem.appendChild(imgContainer);
					fullViewItem.appendChild(label);
					slicesPreview.appendChild(fullViewItem);
				}
				
				// Add all the regular slices
				slicedImages.forEach(slice => {
					const sliceItem = document.createElement('div');
					sliceItem.style.cssText = `
						border: 1px solid #ddd;
						border-radius: 6px;
						overflow: hidden;
						background: white;
						text-align: center;
						padding: 8px;
						transition: transform 0.2s;
					`;
					sliceItem.onmouseover = () => sliceItem.style.transform = 'scale(1.05)';
					sliceItem.onmouseout = () => sliceItem.style.transform = 'scale(1)';
					
					const imgContainer = document.createElement('div');
					imgContainer.className = 'slice-aspect-container';
					
					const img = document.createElement('img');
					img.src = slice.dataURL;
					img.alt = `Slice ${slice.number}`;
					
					const number = document.createElement('div');
					number.textContent = slice.number;
					number.style.cssText = 'font-size: 14px; font-weight: 600; color: #333; margin-top: 4px;';
					
					imgContainer.appendChild(img);
					sliceItem.appendChild(imgContainer);
					sliceItem.appendChild(number);
					slicesPreview.appendChild(sliceItem);
				});
				
				resultContainer.style.display = 'block';
			}
			
			function resetSplitterInterface() {
				const resultContainer = document.getElementById('result-container');
				resultContainer.style.display = 'none';
				
				// Clear image data
				originalImage = null;
				slicedImages = [];
				fullViewImage = null;
				
				// Reload the image
				loadImageForSplitting();
			}
			
			async function downloadZip() {
				if (slicedImages.length === 0) return;
				
				const zip = new JSZip();
				const highResToggle = document.getElementById('high-res-toggle');
				const isHighRes = highResToggle.checked;
				const folderName = isHighRes ? 'high_res_slices' : 'standard_slices';
				
				// Add the full view as slice_00.jpg if available
				if (fullViewImage) {
					const imageData = fullViewImage.dataURL.split(',')[1];
					zip.file(`${folderName}/slice_00_full_view.jpg`, imageData, { base64: true });
				}
				
				// Add each slice to the zip
				slicedImages.forEach(slice => {
					// Convert data URL to blob
					const imageData = slice.dataURL.split(',')[1];
					zip.file(`${folderName}/slice_${String(slice.number).padStart(2, '0')}.jpg`, imageData, { base64: true });
				});
				
				// Add a readme file explaining the full view
				const currentDate = new Date().toISOString().split('T')[0];
				const readmeContent = 
`Instagram Panorama Slicer - Integrated with EXIF Metadata Viewer

This package contains:
- slice_00_full_view.jpg: A complete view of your panorama that fits Instagram's 4:5 aspect ratio
- slice_01.jpg to slice_${String(slicedImages.length).padStart(2, '0')}.jpg: Individual slices of your panorama

For best results on Instagram:
1. Make an instagram carousel post adding slice_01.jpg through slice_${String(slicedImages.length).padStart(2, '0')}.jpg in order
2. Add slice_00_full_view.jpg either as the first or last image in the carousel

Generated on: ${currentDate}
`;
				
				zip.file('README.txt', readmeContent);
				
				// Generate zip file
				const content = await zip.generateAsync({ type: 'blob' });
				saveAs(content, 'instagram_carousel_slices.zip');
			}
			
			// Event listeners for panorama splitter
			splitPanoramaBtn.addEventListener('click', openSplitterModal);
			closeModalBtn.addEventListener('click', closeSplitterModal);
			
			// Close modal when clicking outside
			panoSplitterModal.addEventListener('click', (e) => {
				if (e.target === panoSplitterModal) {
					closeSplitterModal();
				}
			});
			
			// Close modal with escape key
			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape' && panoSplitterModal.style.display === 'block') {
					closeSplitterModal();
				}
			});

			// Pretty print EXIF values with user-friendly names and formatting
			function getPrettyExifInfo(key, value, originalValue = null) {
				const prettyNames = {
					ImageDescription: "Image Description",
					Make: "Camera Make",
					Model: "Camera Model",
					XResolution: "Horizontal Resolution",
					YResolution: "Vertical Resolution",
					ResolutionUnit: "Resolution Unit",
					Software: "Software Used",
					DateTime: "Date & Time Modified",
					Artist: "Artist/Photographer",
					Copyright: "Copyright Information",
					ExifIFDPointer: "EXIF IFD Pointer",
					GPSInfoIFDPointer: "GPS Info Pointer",
					ExposureTime: "Exposure Time",
					FNumber: "Aperture (F-Number)",
					ExposureProgram: "Exposure Program",
					ISOSpeedRatings: "ISO Speed",
					ExifVersion: "EXIF Version",
					DateTimeOriginal: "Date & Time Taken",
					DateTimeDigitized: "Date & Time Digitized",
					ShutterSpeedValue: "Shutter Speed Value",
					ApertureValue: "Aperture Value",
					ExposureBias: "Exposure Compensation",
					MaxApertureValue: "Max Aperture",
					MeteringMode: "Metering Mode",
					LightSource: "Light Source",
					Flash: "Flash Settings",
					FocalLength: "Focal Length",
					SubsecTimeOriginal: "Subsecond Time Original",
					SubsecTimeDigitized: "Subsecond Time Digitized",
					ColorSpace: "Color Space",
					FocalPlaneXResolution: "Focal Plane X Resolution",
					FocalPlaneYResolution: "Focal Plane Y Resolution",
					FocalPlaneResolutionUnit: "Focal Plane Resolution Unit",
					SensingMethod: "Sensing Method",
					FileSource: "File Source",
					SceneType: "Scene Type",
					CustomRendered: "Custom Rendered",
					ExposureMode: "Exposure Mode",
					WhiteBalance: "White Balance",
					DigitalZoomRation: "Digital Zoom Ratio",
					FocalLengthIn35mmFilm: "Focal Length (35mm equivalent)",
					SceneCaptureType: "Scene Capture Type",
					GainControl: "Gain Control",
					Contrast: "Contrast",
					Saturation: "Saturation",
					Sharpness: "Sharpness",
					GPSLatitudeRef: "GPS Latitude Reference",
					GPSLatitude: "GPS Latitude",
					GPSLongitudeRef: "GPS Longitude Reference",
					GPSLongitude: "GPS Longitude",
					GPSAltitude: "GPS Altitude",
				};

				const prettyName = prettyNames[key] || key;
				let prettyValue = value;
				// Use the passed originalValue, or fall back to value if not provided
				const displayOriginalValue =
					originalValue !== null ? originalValue : value;

				// For most fields without special formatting, use the cleaned value
				// Only show original vs cleaned when they're actually different
				let shouldShowBoth = false;

				// Format specific values
				if (key === "ExposureTime" && typeof value === "number") {
					shouldShowBoth = true;
					if (value < 1) {
						prettyValue = `1/${Math.round(1 / value)} sec`;
					} else {
						prettyValue = `${value} sec`;
					}
				} else if (key === "FNumber" && typeof value === "number") {
					shouldShowBoth = true;
					prettyValue = `f/${value}`;
				} else if (key === "ISOSpeedRatings") {
					shouldShowBoth = true;
					prettyValue = `ISO ${value}`;
				} else if (key === "FocalLength" && typeof value === "number") {
					shouldShowBoth = true;
					prettyValue = `${value} mm`;
				} else if (
					key === "FocalLengthIn35mmFilm" &&
					typeof value === "number"
				) {
					shouldShowBoth = true;
					prettyValue = `${value} mm`;
				} else if (
					key === "ExposureBias" &&
					typeof value === "number"
				) {
					shouldShowBoth = true;
					prettyValue =
						value === 0
							? "0 EV"
							: `${value > 0 ? "+" : ""}${value} EV`;
				} else if (key === "ResolutionUnit") {
					shouldShowBoth = false; // Pretty value is sufficient
					const units = {
						1: "No unit",
						2: "Inches",
						3: "Centimeters",
					};
					prettyValue = units[value] || value;
				} else if (key === "ExposureProgram") {
					shouldShowBoth = false; // Pretty value is clear enough
					const programs = {
						0: "Not defined",
						1: "Manual",
						2: "Normal program",
						3: "Aperture priority",
						4: "Shutter priority",
						5: "Creative program",
						6: "Action program",
						7: "Portrait mode",
						8: "Landscape mode",
					};
					prettyValue = programs[value] || value;
				} else if (key === "MeteringMode") {
					shouldShowBoth = false; // Pretty value is clear enough
					const modes = {
						0: "Unknown",
						1: "Average",
						2: "Center-weighted average",
						3: "Spot",
						4: "Multi-spot",
						5: "Pattern",
						6: "Partial",
						255: "Other",
					};
					prettyValue = modes[value] || value;
				} else if (key === "LightSource") {
					shouldShowBoth = false; // Pretty value is clear enough
					const sources = {
						0: "Unknown",
						1: "Daylight",
						2: "Fluorescent",
						3: "Tungsten",
						4: "Flash",
						9: "Fine weather",
						10: "Cloudy weather",
						11: "Shade",
						12: "Daylight fluorescent",
						13: "Day white fluorescent",
						14: "Cool white fluorescent",
						15: "White fluorescent",
						17: "Standard light A",
						18: "Standard light B",
						19: "Standard light C",
						20: "D55",
						21: "D65",
						22: "D75",
						23: "D50",
						24: "ISO studio tungsten",
						255: "Other",
					};
					prettyValue = sources[value] || value;
				} else if (key === "Flash") {
					shouldShowBoth = true;
					// Flash is a complex bitmask, simplify common values
					const flashModes = {
						0: "No flash",
						1: "Flash fired",
						5: "Flash fired, return not detected",
						7: "Flash fired, return detected",
						8: "On, did not fire",
						9: "On, fired",
						13: "On, return not detected",
						15: "On, return detected",
						16: "Off, did not fire",
						20: "Off, did not fire, return not detected",
						24: "Auto, did not fire",
						25: "Auto, fired",
						29: "Auto, fired, return not detected",
						31: "Auto, fired, return detected",
					};
					prettyValue = flashModes[value] || `Flash code: ${value}`;
				} else if (key === "ColorSpace") {
					shouldShowBoth = false; // Pretty value is clear enough
					const spaces = { 1: "sRGB", 65535: "Uncalibrated" };
					prettyValue = spaces[value] || value;
				} else if (key === "ExposureMode") {
					shouldShowBoth = false; // Pretty value is clear enough
					const modes = {
						0: "Auto exposure",
						1: "Manual exposure",
						2: "Auto bracket",
					};
					prettyValue = modes[value] || value;
				} else if (key === "WhiteBalance") {
					shouldShowBoth = false; // Pretty value is clear enough
					const balance = {
						0: "Auto white balance",
						1: "Manual white balance",
					};
					prettyValue = balance[value] || value;
				} else if (key === "SceneCaptureType") {
					shouldShowBoth = true;
					const types = {
						0: "Standard",
						1: "Landscape",
						2: "Portrait",
						3: "Night scene",
					};
					prettyValue = types[value] || value;
				} else if (key === "GainControl") {
					shouldShowBoth = true;
					const controls = {
						0: "None",
						1: "Low gain up",
						2: "High gain up",
						3: "Low gain down",
						4: "High gain down",
					};
					prettyValue = controls[value] || value;
				} else if (
					key === "Contrast" ||
					key === "Saturation" ||
					key === "Sharpness"
				) {
					shouldShowBoth = true;
					const levels = { 0: "Normal", 1: "Soft", 2: "Hard" };
					prettyValue = levels[value] || value;
				} else if (key === "SensingMethod") {
					shouldShowBoth = true;
					const methods = {
						1: "Not defined",
						2: "One-chip color area sensor",
						3: "Two-chip color area sensor",
						4: "Three-chip color area sensor",
						5: "Color sequential area sensor",
						7: "Trilinear sensor",
						8: "Color sequential linear sensor",
					};
					prettyValue = methods[value] || value;
				} else if (key === "GPSLatitude" || key === "GPSLongitude") {
					shouldShowBoth = false; // Don't show raw data for cleaner display
					if (Array.isArray(value) && value.length === 3) {
						const [deg, min, sec] = value;
						// Check if this is decimal minutes format (common in EXIF)
						if (sec === 0 || sec < 0.0001) {
							// Format as degrees and decimal minutes
							prettyValue = `${deg}° ${min.toFixed(6)}'`;
						} else {
							// Format as degrees, minutes, seconds
							prettyValue = `${deg}° ${Math.floor(
								min
							)}' ${sec.toFixed(4)}"`;
						}
					}
				} else if (key === "GPSAltitude" && typeof value === "number") {
					shouldShowBoth = true;
					prettyValue = `${value.toFixed(2)} meters`;
				} else if (
					(key === "XResolution" || key === "YResolution") &&
					typeof value === "number"
				) {
					shouldShowBoth = true;
					prettyValue = `${value} dpi`;
				}

				// Return formatted value based on shouldShowBoth logic
				const cleanedValue = value; // The cleaned/processed value
				const finalValue =
					shouldShowBoth && prettyValue !== cleanedValue
						? `${prettyValue} (${cleanedValue})`
						: prettyValue || cleanedValue;

				return {
					prettyName,
					prettyValue: finalValue,
					originalValue: displayOriginalValue,
				};
			}

			// Convert GPS coordinates from DMS to decimal
			function dmsToDecimal(dms, ref) {
				if (!Array.isArray(dms) || dms.length !== 3) return null;
				const [deg, min, sec] = dms;

				// Handle both decimal minutes and degrees/minutes/seconds formats
				let dec;
				if (sec === 0 || sec < 0.0001) {
					// Decimal minutes format: degrees + decimal_minutes/60
					dec = deg + min / 60;
				} else {
					// Traditional DMS format: degrees + minutes/60 + seconds/3600
					dec = deg + min / 60 + sec / 3600;
				}

				if (ref === "S" || ref === "W") dec = -dec;
				return dec;
			}

			// Handle file selection or drop
			function handleFile(file) {
				// Store the current file for panorama splitter
				currentImageFile = file;
				
				// Validate file type
				if (!file || file.type !== "image/jpeg") {
					metadataDiv.textContent = "Please select a JPG file.";
					// Clean up map when file validation fails
					if (currentMap) {
						currentMap.remove();
						currentMap = null;
					}
					mapDiv.style.display = "none";
					imagePreviewDiv.innerHTML = "";
					hideSplitterButton();
					currentImageFile = null;
					return;
				}
				
				// Display image preview and check for panorama
				const imgUrl = URL.createObjectURL(file);
				const img = new Image();
				img.onload = function() {
					// Check if it's a panoramic image
					if (isPanorama(img.width, img.height)) {
						showSplitterButton();
					} else {
						hideSplitterButton();
					}
				};
				img.src = imgUrl;
				
				imagePreviewDiv.innerHTML = `<img src="${imgUrl}" alt="Preview of dropped JPG file" style="max-width:100%;max-height:400px;border-radius:10px;border:1px solid #ccc;box-shadow:0 2px 8px #ccc;" />`;
				const reader = new FileReader();
				reader.onload = function (event) {
					const arrayBuffer = event.target.result;
					let exifData = {};
					try {
						exifData = EXIF.readFromBinaryFile(arrayBuffer);
					} catch (err) {
						exifData = { error: "Error reading EXIF: " + err };
					}

					// Check if EXIF data exists and has properties
					if (
						exifData &&
						typeof exifData === "object" &&
						exifData !== null &&
						!exifData.error &&
						Object.keys(exifData).length > 0
					) {
						let table =
							'<table style="width:50%;border-collapse:collapse;">';
						for (const key in exifData) {
							// Skip thumbnail field
							if (
								Object.prototype.hasOwnProperty.call(
									exifData,
									key
								) &&
								key !== "thumbnail"
							) {
								let value = exifData[key];
								const originalValue = exifData[key]; // Preserve the true original value

								// Attempt to decode string values for special characters
								if (typeof value === "string") {
									try {
										// Handle common encoding issues
										if (
											value.includes("\uFFFD") ||
											value.includes("â") ||
											value.includes("Ã")
										) {
											// Try UTF-8 decoding
											const decoder = new TextDecoder(
												"utf-8"
											);
											value = decoder.decode(
												new Uint8Array(
													[...value].map((c) =>
														c.charCodeAt(0)
													)
												)
											);
										} else {
											// Handle common character replacements for improperly encoded text
											value = value
												.replace(/Â©/g, "©") // Copyright symbol
												.replace(/â€™/g, "'") // Right single quotation mark
												.replace(/â€œ/g, '"') // Left double quotation mark
												.replace(/â€/g, '"') // Right double quotation mark
												.replace(/â€"/g, "—") // Em dash
												.replace(/â€"/g, "–") // En dash
												.replace(/Ã¡/g, "á") // á
												.replace(/Ã©/g, "é") // é
												.replace(/Ã­/g, "í") // í
												.replace(/Ã³/g, "ó") // ó
												.replace(/Ãº/g, "ú") // ú
												.replace(/Ã±/g, "ñ") // ñ
												.replace(/Ã¼/g, "ü") // ü
												.replace(/Ã¤/g, "ä") // ä
												.replace(/Ã¶/g, "ö") // ö
												.replace(/Ã /g, "à") // à
												.replace(/Ã¨/g, "è") // è
												.replace(/Ã¬/g, "ì") // ì
												.replace(/Ã²/g, "ò") // ò
												.replace(/Ã¹/g, "ù"); // ù
										}
									} catch {
										// If all else fails, keep original value
									}
								}

								// Get pretty-printed information (pass cleaned value for formatting, original for display)
								const exifInfo = getPrettyExifInfo(
									key,
									value,
									originalValue
								);

								table += `<tr>
									<td style='border:1px solid #ccc;padding:2px 6px;vertical-align:top;'>
										<strong style='font-size:18px;'>${exifInfo.prettyName}</strong>
									</td>
									<td style='border:1px solid #ccc;padding:2px 6px;'>
										<div style='font-size:18px;'>${exifInfo.prettyValue}</div>
									</td>
								</tr>`;
							}
						}
						table += "</table>";
						metadataDiv.innerHTML =
							"<strong>EXIF Metadata:</strong>" + table;

						// If GPS data exists, show map
						if (
							exifData.GPSLatitude &&
							exifData.GPSLongitude &&
							exifData.GPSLatitudeRef &&
							exifData.GPSLongitudeRef
						) {
							const lat = dmsToDecimal(
								exifData.GPSLatitude,
								exifData.GPSLatitudeRef
							);
							const lng = dmsToDecimal(
								exifData.GPSLongitude,
								exifData.GPSLongitudeRef
							);
							if (lat !== null && lng !== null) {
								mapDiv.style.display = "block";

								// Destroy existing map if it exists
								if (currentMap) {
									currentMap.remove();
									currentMap = null;
								}

								// Clear the map container
								mapDiv.innerHTML = "";

								// Initialize new Leaflet map
								currentMap = L.map("map").setView(
									[lat, lng],
									13
								);
								L.tileLayer(
									"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
									{
										maxZoom: 19,
										attribution:
											"© OpenStreetMap contributors",
									}
								).addTo(currentMap);
								L.marker([lat, lng])
									.addTo(currentMap)
									.bindPopup("Photo Location")
									.openPopup();

								// Clean up existing button container if it exists
								if (
									currentButtonContainer &&
									currentButtonContainer.parentNode
								) {
									currentButtonContainer.parentNode.removeChild(
										currentButtonContainer
									);
									currentButtonContainer = null;
								}

								// Add map service buttons
								const buttonContainer =
									document.createElement("div");
								currentButtonContainer = buttonContainer; // Track the new container
								buttonContainer.style.cssText = `
									text-align: center;
									margin: 15px 0;
									display: flex;
									gap: 10px;
									justify-content: center;
									flex-wrap: wrap;
								`;

								// Google Maps button
								const googleMapsBtn =
									document.createElement("button");
								googleMapsBtn.textContent =
									"🌍 Open in Google Maps";
								googleMapsBtn.style.cssText = `
									background: #4285f4;
									color: white;
									border: none;
									padding: 10px 15px;
									border-radius: 6px;
									cursor: pointer;
									font-size: 14px;
									font-weight: 500;
									transition: background 0.2s ease;
								`;
								googleMapsBtn.addEventListener(
									"mouseover",
									() => {
										googleMapsBtn.style.background =
											"#3367d6";
									}
								);
								googleMapsBtn.addEventListener(
									"mouseout",
									() => {
										googleMapsBtn.style.background =
											"#4285f4";
									}
								);
								googleMapsBtn.addEventListener("click", () => {
									window.open(
										`https://www.google.com/maps?q=${lat},${lng}`,
										"_blank"
									);
								});

								// OpenStreetMap button
								const osmBtn = document.createElement("button");
								osmBtn.textContent = "🗺️ Open in OpenStreetMap";
								osmBtn.style.cssText = `
									background: #7ebc6f;
									color: white;
									border: none;
									padding: 10px 15px;
									border-radius: 6px;
									cursor: pointer;
									font-size: 14px;
									font-weight: 500;
									transition: background 0.2s ease;
								`;
								osmBtn.addEventListener("mouseover", () => {
									osmBtn.style.background = "#6da85f";
								});
								osmBtn.addEventListener("mouseout", () => {
									osmBtn.style.background = "#7ebc6f";
								});
								osmBtn.addEventListener("click", () => {
									window.open(
										`https://www.openstreetmap.org/?mlat=${lat}&mlon=${lng}&zoom=15`,
										"_blank"
									);
								});

								// Apple Maps button (only show on Apple devices)
								const isAppleDevice =
									/Mac|iPhone|iPad|iPod/.test(
										navigator.userAgent
									);
								if (isAppleDevice) {
									const appleMapsBtn =
										document.createElement("button");
									appleMapsBtn.textContent =
										"🍎 Open in Apple Maps";
									appleMapsBtn.style.cssText = `
										background: #007aff;
										color: white;
										border: none;
										padding: 10px 15px;
										border-radius: 6px;
										cursor: pointer;
										font-size: 14px;
										font-weight: 500;
										transition: background 0.2s ease;
									`;
									appleMapsBtn.addEventListener(
										"mouseover",
										() => {
											appleMapsBtn.style.background =
												"#0051d5";
										}
									);
									appleMapsBtn.addEventListener(
										"mouseout",
										() => {
											appleMapsBtn.style.background =
												"#007aff";
										}
									);
									appleMapsBtn.addEventListener(
										"click",
										() => {
											window.location.href = `maps://?q=${lat},${lng}`;
										}
									);
									buttonContainer.appendChild(appleMapsBtn);
								}

								buttonContainer.appendChild(googleMapsBtn);
								buttonContainer.appendChild(osmBtn);

								// Insert the button container after the map
								mapDiv.parentNode.insertBefore(
									buttonContainer,
									mapDiv.nextSibling
								);
							} else {
								// Clean up map when no valid GPS coordinates
								if (currentMap) {
									currentMap.remove();
									currentMap = null;
								}
								// Clean up button container when no valid GPS coordinates
								if (
									currentButtonContainer &&
									currentButtonContainer.parentNode
								) {
									currentButtonContainer.parentNode.removeChild(
										currentButtonContainer
									);
									currentButtonContainer = null;
								}
								mapDiv.style.display = "none";
							}
						} else {
							// Clean up map when no GPS data
							if (currentMap) {
								currentMap.remove();
								currentMap = null;
							}
							// Clean up button container when no GPS data
							if (
								currentButtonContainer &&
								currentButtonContainer.parentNode
							) {
								currentButtonContainer.parentNode.removeChild(
									currentButtonContainer
								);
								currentButtonContainer = null;
							}
							mapDiv.style.display = "none";
						}
					} else {
						// Handle cases where no EXIF data is found
						if (exifData.error) {
							metadataDiv.innerHTML = `<strong>Error:</strong> ${exifData.error}`;
						} else if (
							!exifData ||
							Object.keys(exifData).length === 0
						) {
							metadataDiv.innerHTML =
								"<strong>No EXIF metadata found</strong><br>This image may not contain EXIF data, or the EXIF data may have been removed during processing/editing.";
						} else {
							// Fallback: show EXIF as pretty-printed JSON
							metadataDiv.innerHTML =
								"<strong>EXIF Metadata:</strong><pre>" +
								JSON.stringify(exifData, null, 2) +
								"</pre>";
						}
						mapDiv.style.display = "none";
					}
				};
				reader.onerror = function () {
					metadataDiv.textContent = "Error reading file.";
					// Clean up map on read error
					if (currentMap) {
						currentMap.remove();
						currentMap = null;
					}
					mapDiv.style.display = "none";
				};
				reader.readAsArrayBuffer(file);
			}

			// Make handleFile available globally for file handling API
			window.handleFile = handleFile;

			// File picker event
			filePicker.addEventListener("change", (e) => {
				if (e.target.files && e.target.files[0]) {
					handleFile(e.target.files[0]);
				}
			});
			// Drag-and-drop events
			// Highlight drop area on dragover
			dropArea.addEventListener("dragover", (e) => {
				e.preventDefault();
				dropArea.style.background = "#e0e0e0";
			});
			// Remove highlight on dragleave
			dropArea.addEventListener("dragleave", (e) => {
				e.preventDefault();
				dropArea.style.background = "";
			});
			// Handle file drop
			dropArea.addEventListener("drop", (e) => {
				e.preventDefault();
				dropArea.style.background = "";
				if (e.dataTransfer.files && e.dataTransfer.files[0]) {
					handleFile(e.dataTransfer.files[0]);
				}
			});

			// Document-wide drag-and-drop events for dropping files anywhere on the page
			document.addEventListener("dragover", (e) => {
				e.preventDefault();
				e.stopPropagation();
				// Add a subtle visual indicator that the page can accept drops
				document.body.style.backgroundColor = "#f8f9fa";
			});

			document.addEventListener("dragleave", (e) => {
				e.preventDefault();
				e.stopPropagation();
				// Only remove the indicator if we're leaving the document entirely
				if (e.target === document.documentElement) {
					document.body.style.backgroundColor = "";
				}
			});

			document.addEventListener("drop", (e) => {
				e.preventDefault();
				e.stopPropagation();
				// Remove the visual indicator
				document.body.style.backgroundColor = "";
				// Also remove drop area highlight in case it was active
				dropArea.style.background = "";

				if (e.dataTransfer.files && e.dataTransfer.files[0]) {
					handleFile(e.dataTransfer.files[0]);
				}
			});

			// Social sharing functions
			function shareToTwitter() {
				const url = encodeURIComponent(window.location.href);
				const text = encodeURIComponent(
					"Check out this EXIF Metadata Viewer - extract photo metadata and GPS coordinates from JPEG files!"
				);
				window.open(
					`https://twitter.com/intent/tweet?url=${url}&text=${text}`,
					"_blank",
					"width=550,height=420"
				);
			}

			function shareToFacebook() {
				const url = encodeURIComponent(window.location.href);
				window.open(
					`https://www.facebook.com/sharer/sharer.php?u=${url}`,
					"_blank",
					"width=580,height=296"
				);
			}

			function shareToLinkedIn() {
				const url = encodeURIComponent(window.location.href);
				const title = encodeURIComponent("EXIF Metadata Viewer");
				const summary = encodeURIComponent(
					"A web app to extract and view EXIF metadata from JPEG files, including GPS coordinates with map visualization."
				);
				window.open(
					`https://www.linkedin.com/sharing/share-offsite/?url=${url}&title=${title}&summary=${summary}`,
					"_blank",
					"width=580,height=296"
				);
			}

			function shareToReddit() {
				const url = encodeURIComponent(window.location.href);
				const title = encodeURIComponent(
					"EXIF Metadata Viewer - Extract photo metadata and GPS coordinates"
				);
				window.open(
					`https://reddit.com/submit?url=${url}&title=${title}`,
					"_blank",
					"width=580,height=500"
				);
			}

			function shareByEmail() {
				const subject = encodeURIComponent(
					"Check out this EXIF Metadata Viewer"
				);
				const body = encodeURIComponent(
					`I thought you might be interested in this EXIF Metadata Viewer web app:\n\n${window.location.href}\n\nIt extracts metadata from JPEG files and shows GPS coordinates on a map!`
				);
				window.location.href = `mailto:?subject=${subject}&body=${body}`;
			}

			function copyLink() {
				if (navigator.clipboard && window.isSecureContext) {
					navigator.clipboard
						.writeText(window.location.href)
						.then(() => {
							showCopyNotification();
						})
						.catch(() => {
							fallbackCopyTextToClipboard(window.location.href);
						});
				} else {
					fallbackCopyTextToClipboard(window.location.href);
				}
			}

			function fallbackCopyTextToClipboard(text) {
				const textArea = document.createElement("textarea");
				textArea.value = text;
				textArea.style.position = "fixed";
				textArea.style.left = "-999999px";
				textArea.style.top = "-999999px";
				document.body.appendChild(textArea);
				textArea.focus();
				textArea.select();
				try {
					document.execCommand("copy");
					showCopyNotification();
				} catch (err) {
					console.error("Fallback: Oops, unable to copy", err);
				}
				document.body.removeChild(textArea);
			}

			function showCopyNotification() {
				const notification = document.createElement("div");
				notification.textContent = "🔗 Link copied to clipboard!";
				notification.style.cssText = `
					position: fixed;
					top: 70px;
					right: 20px;
					background: #4caf50;
					color: white;
					padding: 12px 16px;
					border-radius: 8px;
					font-size: 14px;
					z-index: 1001;
					box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
					opacity: 0;
					transition: opacity 0.3s ease;
				`;

				document.body.appendChild(notification);

				// Fade in
				setTimeout(() => {
					notification.style.opacity = "1";
				}, 100);

				// Remove after 3 seconds
				setTimeout(() => {
					notification.style.opacity = "0";
					setTimeout(() => {
						if (notification.parentNode) {
							notification.parentNode.removeChild(notification);
						}
					}, 300);
				}, 3000);
			}
		</script>
	</body>
</html>
